<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Kenyan Food Crush</title>
<style>
body {
  font-family: 'Arial', sans-serif;
  text-align: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  margin: 0;
  padding: 0.5rem;
  min-height: 100vh;
  color: white;
  overflow-x: hidden;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.game-container {
  max-width: 500px;
  margin: 0 auto;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  padding: 1rem;
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
}

h1 {
  font-size: 2rem;
  margin-bottom: 0.5rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
  background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

@media (max-width: 480px) {
  .game-container {
    padding: 0.5rem;
    margin: 0.25rem;
  }
  
  h1 {
    font-size: 1.5rem;
  }
}

.score-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  background: rgba(255, 255, 255, 0.2);
  padding: 0.75rem;
  border-radius: 15px;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.score-info {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

#score {
  font-size: 1.2rem;
  font-weight: bold;
  margin-bottom: 0.25rem;
}

#highScore {
  font-size: 0.9rem;
  opacity: 0.8;
  color: #feca57;
}

@media (max-width: 480px) {
  .score-container {
    padding: 0.5rem;
    gap: 0.25rem;
  }
  
  #score {
    font-size: 1rem;
  }
  
  #highScore {
    font-size: 0.8rem;
  }
}

#resetBtn {
  background: linear-gradient(45deg, #ff6b6b, #ee5a24);
  border: none;
  padding: 0.6rem 1.2rem;
  border-radius: 20px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  font-size: 0.9rem;
}

#resetBtn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
}

#resetBtn:active {
  transform: translateY(0);
}

@media (max-width: 480px) {
  #resetBtn {
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
  }
}

.grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 3px;
  max-width: 400px;
  margin: auto;
  background: rgba(255, 255, 255, 0.1);
  padding: 10px;
  border-radius: 20px;
  box-shadow: inset 0 4px 8px rgba(0, 0, 0, 0.1);
  touch-action: none;
} 

@media (max-width: 480px) {
  .grid {
    max-width: 300px;
    gap: 2px;
    padding: 8px;
  }
} 

.candy {
  width: 100%;
  aspect-ratio: 1 / 1;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  border: 2px solid rgba(255, 255, 255, 0.3);
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}

.candy:hover, .candy:active {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.candy.selected {
  border: 3px solid #feca57;
  box-shadow: 0 0 15px rgba(254, 202, 87, 0.6);
  transform: scale(1.1);
}

@media (max-width: 480px) {
  .candy {
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .candy.selected {
    border: 2px solid #feca57;
  }
}

/* Fallback colors if images don't load */
.ugali { background-color: #f39c12; }
.omena { background-color: #3498db; }
.mayai { background-color: #f1c40f; }
.ndengu { background-color: #27ae60; }
.bean { background-color: #8e44ad; }
.chapati { background-color: #e74c3c; }

.popping {
  animation: pop 0.4s ease-out forwards;
}

@keyframes pop {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.2); opacity: 0.8; }
  100% { transform: scale(0); opacity: 0; }
}

.falling {
  animation: fall 0.3s ease-in forwards;
}

@keyframes fall {
  from { transform: translateY(-100%); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.match-feedback {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(46, 204, 113, 0.9);
  color: white;
  padding: 1rem 2rem;
  border-radius: 25px;
  font-size: 1.2rem;
  font-weight: bold;
  z-index: 1000;
  animation: fadeInOut 1s ease-out forwards;
}

.high-score-feedback {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(45deg, #feca57, #ff9ff3);
  color: white;
  padding: 1.5rem 2.5rem;
  border-radius: 25px;
  font-size: 1.4rem;
  font-weight: bold;
  z-index: 1000;
  text-align: center;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  animation: highScoreAnim 2s ease-out forwards;
}

@keyframes highScoreAnim {
  0% { 
    opacity: 0; 
    transform: translate(-50%, -50%) scale(0.3) rotate(-10deg); 
  }
  30% { 
    opacity: 1; 
    transform: translate(-50%, -50%) scale(1.2) rotate(5deg); 
  }
  60% { 
    transform: translate(-50%, -50%) scale(1) rotate(0deg); 
  }
  100% { 
    opacity: 0; 
    transform: translate(-50%, -50%) scale(0.8) rotate(0deg); 
  }
}
</style>
</head>
<body>
<div class="game-container">
  <h1>ðŸ‡°ðŸ‡ª Kenyan Food Crush</h1>
  <div class="score-container">
    <div class="score-info">
      <div id="score">Score: 0</div>
      <div id="highScore">High Score: 0</div>
    </div>
    <button id="resetBtn">Reset Game</button>
  </div>
  <div class="grid" id="grid"></div>
</div>

<script>
  const width = 8;
  const grid = document.getElementById('grid');
  const scoreDisplay = document.getElementById('score');
  const highScoreDisplay = document.getElementById('highScore');
  const resetBtn = document.getElementById('resetBtn');

  // Kenyan foods with their class names and image paths
  const foods = ['ugali', 'omena', 'mayai', 'ndengu', 'bean', 'chapati'];
  
  // Image mapping - replace these URLs with your actual image paths
  const imageMap = {
    ugali: 'images/ugali.jpg',
    omena: 'images/omena.jpg', 
    mayai: 'images/mayai.jpg',
    ndengu: 'images/ndengu.jpg',
    bean: 'images/bean.jpg',
    chapati: 'images/chapati.jpg'
  };
  
  let candies = [];
  let selectedCandy = null;
  let score = 0;
  let isProcessing = false;
  
  // Score storage configuration
  const SCORE_KEY = 'kenyanFoodCrushScore';
  const HIGH_SCORE_KEY = 'kenyanFoodCrushHighScore';
  const SCORE_TIMESTAMP_KEY = 'kenyanFoodCrushTimestamp';
  const SCORE_EXPIRY_HOURS = 24; // Score expires after 24 hours

  function getRandomFood() {
    return foods[Math.floor(Math.random() * foods.length)];
  }

  // Create the initial board
  function createBoard() {
    grid.innerHTML = '';
    candies = [];
    
    for(let i = 0; i < width * width; i++) {
      const food = getRandomFood();
      const candy = document.createElement('div');
      candy.className = `candy ${food}`;
      candy.style.backgroundImage = `url('${imageMap[food]}')`;
      candy.setAttribute('draggable', true);
      candy.setAttribute('data-id', i);
      grid.appendChild(candy);
      candies.push(candy);
    }
    
    // Ensure no initial matches
    while(hasMatches()) {
      regenerateBoard();
    }
    
    addInteractionEvents();
  }

  function regenerateBoard() {
    candies.forEach((candy, index) => {
      const food = getRandomFood();
      candy.className = `candy ${food}`;
      candy.style.backgroundImage = `url('${imageMap[food]}')`;
    });
  }

  // Score storage functions
  function saveToStorage(key, value) {
    try {
      // Try localStorage first
      if (typeof Storage !== 'undefined' && localStorage) {
        localStorage.setItem(key, value);
        return true;
      }
    } catch (e) {
      console.log('localStorage not available, using memory storage');
    }
    
    // Fallback to in-memory storage
    if (!window.gameStorage) {
      window.gameStorage = {};
    }
    window.gameStorage[key] = value;
    return false;
  }
  
  function getFromStorage(key) {
    try {
      // Try localStorage first
      if (typeof Storage !== 'undefined' && localStorage) {
        return localStorage.getItem(key);
      }
    } catch (e) {
      console.log('localStorage not available, using memory storage');
    }
    
    // Fallback to in-memory storage
    if (window.gameStorage && window.gameStorage[key]) {
      return window.gameStorage[key];
    }
    return null;
  }
  
  function loadScore() {
    const savedScore = getFromStorage(SCORE_KEY);
    const savedTimestamp = getFromStorage(SCORE_TIMESTAMP_KEY);
    const currentTime = Date.now();
    
    // Check if score has expired (24 hours)
    if (savedScore && savedTimestamp) {
      const hoursElapsed = (currentTime - parseInt(savedTimestamp)) / (1000 * 60 * 60);
      if (hoursElapsed < SCORE_EXPIRY_HOURS) {
        return parseInt(savedScore) || 0;
      }
    }
    
    // Score expired or doesn't exist, reset
    saveScore(0);
    return 0;
  }
  
  function saveScore(newScore) {
    saveToStorage(SCORE_KEY, newScore.toString());
    saveToStorage(SCORE_TIMESTAMP_KEY, Date.now().toString());
    
    // Update high score if needed
    const currentHighScore = getHighScore();
    if (newScore > currentHighScore) {
      saveToStorage(HIGH_SCORE_KEY, newScore.toString());
      showHighScoreFeedback(newScore);
    }
  }
  
  function getHighScore() {
    const highScore = getFromStorage(HIGH_SCORE_KEY);
    return parseInt(highScore) || 0;
  }

  function addInteractionEvents() {
    candies.forEach(candy => {
      // Touch events for mobile
      candy.addEventListener('touchstart', handleTouchStart, { passive: false });
      candy.addEventListener('touchend', handleTouchEnd, { passive: false });
      
      // Mouse events for desktop
      candy.addEventListener('click', handleClick);
      
      // Prevent default drag behavior
      candy.addEventListener('dragstart', e => e.preventDefault());
    });
  }
  
  function handleTouchStart(e) {
    e.preventDefault();
    if (isProcessing) return;
    
    const candyId = parseInt(e.target.getAttribute('data-id'));
    handleCandySelection(candyId);
  }
  
  function handleTouchEnd(e) {
    e.preventDefault();
  }
  
  function handleClick(e) {
    if (isProcessing) return;
    
    const candyId = parseInt(e.target.getAttribute('data-id'));
    handleCandySelection(candyId);
  }
  
  function handleCandySelection(candyId) {
    if (selectedCandy === null) {
      // First selection
      selectedCandy = candyId;
      candies[candyId].classList.add('selected');
    } else if (selectedCandy === candyId) {
      // Deselect same candy
      candies[selectedCandy].classList.remove('selected');
      selectedCandy = null;
    } else {
      // Second selection - try to swap
      const firstCandy = selectedCandy;
      const secondCandy = candyId;
      
      // Remove selection highlight
      candies[selectedCandy].classList.remove('selected');
      selectedCandy = null;
      
      // Try to make the move
      attemptSwap(firstCandy, secondCandy);
    }
  }
  
  async function attemptSwap(id1, id2) {
    if (isAdjacent(id1, id2)) {
      swapCandies(id1, id2);
      
      if (hasMatches()) {
        isProcessing = true;
        await processMatches();
        isProcessing = false;
      } else {
        // Invalid move - swap back
        swapCandies(id1, id2);
      }
    }
  }

  function isAdjacent(id1, id2) {
    const row1 = Math.floor(id1 / width);
    const col1 = id1 % width;
    const row2 = Math.floor(id2 / width);
    const col2 = id2 % width;
    
    const rowDiff = Math.abs(row1 - row2);
    const colDiff = Math.abs(col1 - col2);
    
    return (rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1);
  }

  function swapCandies(id1, id2) {
    const candy1 = candies[id1];
    const candy2 = candies[id2];
    
    const tempClass = candy1.className;
    const tempImage = candy1.style.backgroundImage;
    
    candy1.className = candy2.className;
    candy1.style.backgroundImage = candy2.style.backgroundImage;
    
    candy2.className = tempClass;
    candy2.style.backgroundImage = tempImage;
  }

  function hasMatches() {
    return findMatches().length > 0;
  }

  function findMatches() {
    let matches = [];
    
    // Check horizontal matches
    for (let row = 0; row < width; row++) {
      let count = 1;
      let currentFood = getFoodType(row * width);
      
      for (let col = 1; col < width; col++) {
        const index = row * width + col;
        const food = getFoodType(index);
        
        if (food === currentFood) {
          count++;
        } else {
          if (count >= 3) {
            for (let i = col - count; i < col; i++) {
              matches.push(row * width + i);
            }
          }
          count = 1;
          currentFood = food;
        }
      }
      
      if (count >= 3) {
        for (let i = width - count; i < width; i++) {
          matches.push(row * width + i);
        }
      }
    }
    
    // Check vertical matches
    for (let col = 0; col < width; col++) {
      let count = 1;
      let currentFood = getFoodType(col);
      
      for (let row = 1; row < width; row++) {
        const index = row * width + col;
        const food = getFoodType(index);
        
        if (food === currentFood) {
          count++;
        } else {
          if (count >= 3) {
            for (let i = row - count; i < row; i++) {
              matches.push(i * width + col);
            }
          }
          count = 1;
          currentFood = food;
        }
      }
      
      if (count >= 3) {
        for (let i = width - count; i < width; i++) {
          matches.push(i * width + col);
        }
      }
    }
    
    return [...new Set(matches)]; // Remove duplicates
  }

  function getFoodType(index) {
    const classes = candies[index].className.split(' ');
    return classes.find(cls => foods.includes(cls));
  }

  async function processMatches() {
    let totalMatches = 0;
    
    while (hasMatches()) {
      const matches = findMatches();
      totalMatches += matches.length;
      
      // Animate removal
      matches.forEach(index => {
        candies[index].classList.add('popping');
      });
      
      await new Promise(resolve => setTimeout(resolve, 400));
      
      // Remove matches
      matches.forEach(index => {
        candies[index].className = 'candy';
        candies[index].style.backgroundImage = '';
      });
      
      // Apply gravity
      applyGravity();
      
      await new Promise(resolve => setTimeout(resolve, 300));
    }
    
    if (totalMatches > 0) {
      updateScore(totalMatches);
      showMatchFeedback(totalMatches);
    }
  }

  function applyGravity() {
    for (let col = 0; col < width; col++) {
      const column = [];
      
      // Collect non-empty candies from bottom to top
      for (let row = width - 1; row >= 0; row--) {
        const index = row * width + col;
        const foodType = getFoodType(index);
        if (foodType) {
          column.push(foodType);
        }
      }
      
      // Fill column from bottom up
      for (let row = width - 1; row >= 0; row--) {
        const index = row * width + col;
        if (column.length > 0) {
          const food = column.shift();
          candies[index].className = `candy ${food}`;
          candies[index].style.backgroundImage = `url('${imageMap[food]}')`;
        } else {
          const food = getRandomFood();
          candies[index].className = `candy ${food} falling`;
          candies[index].style.backgroundImage = `url('${imageMap[food]}')`;
          // Remove falling class after animation
          setTimeout(() => {
            candies[index].classList.remove('falling');
          }, 300);
        }
      }
    }
  }

  function updateScore(points) {
    score += points * 10; // 10 points per match
    scoreDisplay.textContent = `Score: ${score}`;
    saveScore(score);
  }
  
  function updateScoreDisplay() {
    scoreDisplay.textContent = `Score: ${score}`;
    highScoreDisplay.textContent = `High Score: ${getHighScore()}`;
  }

  function showMatchFeedback(matches) {
    const feedback = document.createElement('div');
    feedback.className = 'match-feedback';
    feedback.textContent = `+${matches * 10} points!`;
    document.body.appendChild(feedback);
    
    setTimeout(() => {
      feedback.remove();
    }, 1000);
  }
  
  function showHighScoreFeedback(newHighScore) {
    const feedback = document.createElement('div');
    feedback.className = 'high-score-feedback';
    feedback.innerHTML = `ðŸŽ‰ NEW HIGH SCORE!<br>${newHighScore} points`;
    document.body.appendChild(feedback);
    
    setTimeout(() => {
      feedback.remove();
    }, 2000);
  }

  function resetGame() {
    score = 0;
    updateScoreDisplay();
    saveScore(0);
    createBoard();
  }

  resetBtn.addEventListener('click', resetGame);

  // Initialize the game
  function initGame() {
    score = loadScore();
    updateScoreDisplay();
    createBoard();
  }

  // Initialize the game
  initGame();
</script>
</body>
</html>